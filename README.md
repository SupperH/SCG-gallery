# *bug记录 & 改进*
##  2025/5/7
删除cos存储对象时 url不能传完整url 只需要路径即可 https://cloud.tencent.com/document/product/436/65939  
目前只能删除缩略图和压缩后的webp格式图 原图不会删除实际还保存在cos中 这个看需求   
搜图看是否可以进行优化 比如更改api 或者更改重试机制 目前使用的百度的api 不支持webp格式  
**目前放开了前端SpaceDetailPage创建图片和批量编辑按钮的条件判断 做测试 后期要把判断加回去 因为严格来说创建图片是只有空间管理员可以做的 这个空间可以升级为团队空间**  

## 2025/5/9
批量抓取改为策略模式 解耦 抓取逻辑和业务逻辑  
增加额外的抓取接口 **（仅做学习用）**  
api.getpicturebatch包下 策略模式+调用入口 现在service代码只需要调用一个方法 不需要关注抓图的内部逻辑  
后期需要增加抓取接口只需要创建策略类继承接口即可  






# 1. 项目初始化
工具包：
- mybatisPlus
- hutool
- knife4j 自动生成接口文档   访问： http://localhost:9999/api/doc.html

**项目基础代码** 
请求响应体封装

    封装前端传参和后端返回参数的实体类，便于传输数据  
    com.scg.scgpicturebackend.common

异常封装 

    封装异常类，便于处理异常自定义错误码，对错误进行收敛，便于前端统一处理
    定义全局异常处理器
    com.scg.scgpicturebackend.exception

**解决跨域**

只在浏览器出现，是浏览器的同源策略，如果发送请求的网址和接收请求的网址是相同的 否则就会有跨域问题

 解决跨域问题的方法：

    1.后端来支持跨域
    2.代理 nginx 第三方工具等方法
    3.直接用croscheck注解
    4.全局跨域配置 com.scg.scgpicturebackend.config.CorsConfig


# 2. 用户模块
注册，登录，获取当前登录用户，注销，权限控制，用户管理

使用mybatisX插件生成实体类等代码 

- 定义user表的枚举类
- 定义请求接受类和请求封装类 dto
- 设置要返回给前端哪些数据（脱敏） vo
- 权限控制 配合aop和注解类实现 authInterceptor+AuthCheck
- 分页 使用mybatisplus分页 
-  **天坑： 3.5.9的mybatisplus要额外安装分页插件和配置一个配置类**
-  **天坑： 要注意 前端和后端的long精度不一样 如果直接传的话可能会丢失精度 因为这里的user id是assign_id策略 生成的long比较大 可能前端没有这么高的精度 所以要定义一个配置类JsonConfig来对long进行转换**



#  3. 图片模块
管理员功能： 上传，创建，管理，修改  
用户功能： 查看，搜索，查看详情，下载  
主页的公共图库 都可以进行浏览 图片管理只有管理员可以浏览
主页图库显示的图片都是一样的 但是管理员不会脱敏 用户会脱敏
**目前只有管理员可以上传图片**

**tips：数据库加索引 如果索引varchar类型长度累计和大于2048 就会报错**

图片上传路径不用自己服务器 使用腾讯云的cos对象存储 

**上传图片方案：**  
上传图片时直接保存记录：**在用户上传图片后，系统立即生成图片的完整数据记录**
（包括图片url和其他信息）无需等待用户提交，图片信息就立刻存入数据库，之后用户再填写其他图片信息  
**然后当点击创建按钮 相当于编辑了已有图片记录的信息 便于对图片进行朔源**

上传区分新增和更新两个操作使用saveorupdate （目前只有管理员可以更新图片 更新调用的也是新增接口 但是前台会传这个图片的id 如果图片id有值在数据库 
那么说明是更新操作）

解析图片信息：  
这里使用了腾讯云cos 直接使用**数据万象**服务获取图片基础信息  

**根据腾讯云接口文档编码**  
引入对象存储的依赖cos_api

配置文件CosClientConfig，以及本地用的application-local.yml  
文件上传下载通用类：CosManager 单纯的通过腾讯云提供的api上传下载


**下载图片方案**  
先通过后端服务器进行权限校验  
然后返回给前端一个临时密钥  
之后前端可以凭借密钥直接从对象存储下载，不用经过服务端中转 性能更高

**通用文件上传服务**  
FileManager 包含一些逻辑处理代码


# 4 用户传图
用户上传 审核 涉及用户上传（UGC）就需要增加审核功能  
通过url创建图片  
批量抓取和创建图片  

**用户上传，审核**  
修改图片查询 给查询增加审核条件

**url导入图片**  
下载图片 后端从服务器下载图片到本地  
**校验图片**  
**对url本身进行校验** 首先校验url字符串本身合法性 然后使用**head**请求来去获取url对应文件的辕信息
head请求只返回http响应头信息，不会下载文件内容 **注意不是所有服务器都支持head请求**
**上传图片**
直接上传到cos

**更改FileManager使用模板方法 去优化选择图片上传的方法和用url上传图片的方法**  
把公共部分拆出来 然后让子类去自定义自己的实现逻辑
**废弃掉FileManager类**  
使用manager/upload文件夹中的使用模板方法重构的类  
**修改pictureservice的调用代码 改为使用模板方法的上传方法调用**  

**批量抓取图片**  
爬！  
批量从网络抓取并创建图片的功能 千万别给普通用户开放，这相当于所有用户使用我们服务器作为爬虫源头 这太刑了

而且爬也别去爬素材网站 绝大多的素材网站都有版权保护  
这里选择从搜索引擎获取图片

有两种常见的做法：  
1. 请求到完整页面内容，对页面的html结构进行解析，提取到图片的地址，再通过url下载
2. 直接调用后端后去图片地址接口拿到数据

具体使用哪种方法看情况分析，这里我**使用bing图片进行抓取** bing图片网页下拉刷新查看接口即可 简单来说你想办法获取新图片的加载就很容易找到  
其他网站大差不差 这里只做学习用 不提供任何建议 
bing图片的请求地址 https://cn.bing.com/images/async?q=%图片内容&mmasync=1  
地址中的mmasync一定要加上

**使用jsoup来提取html文档解析图片地址 非常轻量**  
先通过类选择器找到最外层元素 然后通过子元素选择器找到图片地址

**抓取规则：**  
输入搜索关键字，单次抓取最好不超过30条



# 5.图片优化
图片查询优化 - 分布式缓存，本地缓存，多级缓存  
图片上传优化 - 压缩，秒传，分片上传，断点续传  
图片加载优化 - 懒加载，缩略图，CDN加速，浏览器缓存  
图片存储优化 - 降频存储（冷热数据分离） 清理策略  

**使用redis进行缓存**  
使用spring data redis 作为redis的操作库


**Caffeine本地缓存**  
本地缓存是本地内存的缓存，它不需要持久化，也不需要网络连接，它直接存在于JVM的内存中，所以它的速度非常快，但是它不能持久化，所以当JVM重启时，它将丢失。  
适用于小型数据库 因为在服务器 服务器内存很宝贵
不需要服务器共享数据的单机应用
高频，低延迟的访问场景  session也是存在了本地缓存中

本地缓存需要自己创建初始化缓存结构 可以理解为自己要new一个hashmap  
本地缓存本身是服务器隔离，占用服务器内存，key可以精简点不用加前缀

**多级缓存，redis和本地缓存一起使用 这样可以兼顾本地缓存和redis缓存的优点**  
先查本地缓存-有直接返回-没有查询redis-有返回-没有查询数据库-更新双缓存

**图片压缩**
把图片格式转为体积更小的格式，比如webP，对图片质量进行压缩，缩小图片尺寸  
这里使用第一种方法，因为图片网站尽量不要影响图片的质量

webP: 比png文件小26%，比JPEG文件小25%-34% 支持透明背景 兼容大部分主流浏览器
AVIF：基于AV1视频编码技术的压缩及时 压缩效率更高  
这里选择上传时压缩，一次压缩永久保存，无需额外的压缩费用  
压缩逻辑： 先上传原图 然后再压缩一张图片保存 然后把压缩后的图片名(webp)存入数据库 也就是说 实际在cos反而数据变多了 但是我们网站查询数据变少了  
         后续可以考虑上传成功后从cos中删除原图 或者保存原图和压缩后的图的数据在数据库 但是查询只查询压缩后的图

修改CosManager

**文件秒传**  
客户端生成文件唯一标识 上传时通过客户端计算唯一标识 如果能够在数据库查询到说明存在相同文件 那么直接返回文件存储路径，不存在再正常上传  
这个项目不适合用秒传，因为文件比较小，重复文件也较少，而且使用了腾讯云cos存储 只能通过唯一文件地址去查询文件  
但是可以设计一个关联表 用户1的图片地址为/1/a.png 用户2的图片地址为/2/a.png 然后为他们创建一个快捷方式一样的功能 让这两个地址都指向/b.png 相当于做一个数据库的关联表

**断点续传**  
原理是把一个文件切分成多个块 如果中断从上次最后上传的块开始上传  
断点续传和分块上传是一起用的  
这个功能腾讯云cos也有提供  
这里不做实现 知道这个原理就行

**图片缩略图**
首页的图片应该生成一份尺寸更小的缩略图，点击图片或者浏览图片的时候才加载原图  
使用cos的图片持久化处理  
picture表新增缩略图url字段  
修改CosManager  

现在图片大小顺序为 缩略图 < 压缩图 < 原图

**懒加载**
避免一次性加载所有图片，只有当资源需要显示才加载，比如图片列表 只加载当前屏幕显示的图片 然后当滚动的时候才加载
其实分页相当于这个功能了 其他的都是前端改动后端不用改动


**浏览器缓存**
通过设置http头信息，让用户浏览器把资源缓存在本地，在用户再次访问同样的资源 直接加载缓存，不用请求服务器
设置cache-control public，private，no-cache，no-store
但是要确保缓存及时更新，给文件添加日期随机数防止重复

**CDN**
通过将图片文件发送到全球各地的节点，用户访问时访问离自己地址最近的节点去拿资源  
**CDN请求核心过程：**
1. 用户文件有源站（最原始存储图片的位置 这个项目是COS） 上传到CDN服务进行缓存
2. 当用户请求图片时，CDN会根据用户的地理位置，返回离用户最近的CDN节点缓存的图片资源
3. 未命中缓存的图片会从源站获取，并缓存再CDN节点，让后续用户访问，俗称回源

**优点**
快，安全。 COS倾向存储，CDN倾向网络请求 资源访问高，流量消耗大，要考虑使用CDN  
CDN的流量和请求单价低于对象存储，而且更加安全，可以**保护源站地址不被泄露**  这样访问就变成了先去CDN然后CDN去源站拿数据（前提是没命中缓存在CDN上）这也保护了源站的安全性  
如果系统不安全 那么就想办法加一个中间层

CDN使用起来简单，但是怎么安全的使用很麻烦  
1. 缓存策略：为静态资源（如图片，css，js）设置长期缓存时间，减少回源的次数和消耗
2. 防盗链：配置refer防盗链防止盗刷 比如仅允许自己的域名可以加载图片
3. 单ip限制
4. 设置https，配置ssl证书
5. 给CDN加监控告警 一定时间超出了配置的流量直接告警
6. 节点选择 非必要不要开全球CDN节点
7. 开启访问日志 分析用户行为和流量来源 适合访问量较大的场景 好像也要钱

**上线后再实现这个功能**


**图片存储优化**  
**数据沉降**配置多久后 文件沉降到低频存储，归档存储，深度归档存储  
每种存储的存储价格都不一样 越靠后的越便宜  
但是需要注意 越靠后的数据虽然存储价格不贵 但是后续访问 回源 取回费用较贵  
**所以 应该先分析，再沉降**

**数据沉降和数据的冷热分离概念是比较接近的**，冷热数据分离是根据数据的访问热度，将访问频繁的数据和交少的数据存储在不同的存储层中  

二者的差距：
个人理解的是 数据沉降更秦湘语关注一个对象的生命周期（一个资源从热到冷） 目标更多的是降低存储成本，配置沉降规则后也一般不会调整
冷热数据分离更关注整个系统的资源分布，比如热门图片放到高性能磁盘，冷门图片归档存储，目标是同时优化性能和节约成本，数据的热度可以实时调整  
**这里要知道这个思路**  

**数据清理**
页面点击删除后 使用async异步启动子线程去删除cos中的数据

使用redis管理sesison 引入springsession+redis 修改配置  
这样登陆后 会保存3个key  
一个是session本身，session过期时间，session一些额外的信息



# 空间模块
管理员 管理空间  
用户创建私有空间  
私有空间权限控制  
空间级别和限额控制  

私有空间上传图片不需要管理员进行审核  
把空间抽象出来 和之前公共图库完全分开 尽量只额外增加空间相关的逻辑和代码 减少对代码的修改  
后续还要开发团队共享空间  

**空间管理**  
crud  

**创建私有空间，但是需要加限制，最多只能创建一个**  
使用**加锁+事务**解决 SpaceService.addSpace  
```java
 @Override
    @Transactional
    public long addSpace(SpaceAddRequest spaceAddRequest, User loginUser) {
        //1.填充参数默认值
        //转换实体类和DTO
        Space space = new Space();
        BeanUtils.copyProperties(spaceAddRequest, space);
        /*设置默认值*/
        if(StrUtil.isBlank(space.getSpaceName())){
            space.setSpaceName("默认空间");
        }
        if(space.getSpaceLevel() == null){
            space.setSpaceLevel(SpaceLevelEnum.COMMON.getValue());
        }
        /*填充容量和大小*/
        this.fillSpaceBySpaceLevel(space);

        //2.校验参数
        this.validSpace(space,true);

        //3.校验权限 非管理员只能创建普通空间
        Long userId = loginUser.getId();
        space.setUserId(userId);

        if(SpaceLevelEnum.COMMON.getValue() != space.getSpaceLevel() && !userService.isAdmin(loginUser)){
            throw new BusinessException(ErrorCode.NO_AUTH_ERROR,"非管理员只能创建普通空间");
        }

        //4.控制同一个用户只能创建一个私有空间 加锁
        /*相同值的对象是有同一个存储空间的 使用intern 这样的话不同的string对象但是值一样可以得到同一个数据*/
        String lock = String.valueOf(userId).intern();
        //根据用户id 为相同用户加锁
        synchronized (lock){
            //根据userid去space表判断用户是否已经创建过空间
            boolean exists = this.lambdaQuery()
                    .eq(Space::getUserId, userId)
                    .exists(); // exists比count快 因为count是扫全表

            //如果已有空间 不能再创建
            ThrowUtils.throwIf(exists,ErrorCode.OPERATION_ERROR,"用户已经创建过空间");
            boolean save = this.save(space);
            ThrowUtils.throwIf(!save,ErrorCode.OPERATION_ERROR,"保存空间信息到数据库失败");

            //返回新写入的数据id
            return space.getId();
        }
    }
```
**注意：这里使用transactional注解实现事务是有问题的**  

**因为注解打在方法上 ，交给spring去管理，spring会在方法执行完毕后提交，事务在没有提交之前 数据库查询的数据不是最新的
假如两个用户前后准备进入锁的临界区 然后A用户执行完 锁释放了 但是这个时候事务还没有提交，但是锁释放了
B可以进入临界区执行逻辑 而且由于事务没提交 查询的数据不是最新的 B也插入成功 这就会导致冲突**

所以这里使用编程式事务，而不是注解事务

**私有空间权限控制**  
对之前所有的图片操作都添加空间有关的权限校验逻辑

**空间级别和限额操作**  
每次上传图片前，都要校验空间剩余额度是否足够，每次上传和删除图片时，都要更新额度  
这里优化业务 对业务进行优化  
比如：  
单张图片最大5m，即便空间满了再允许上传一张图片影响也不大
即便有用户在超额前瞬间大量上传图片，对系统的影响也不大，后续可以通过限流+定时任务检测空间等策略，尽早发现这些特殊情况的发生
pictureServiceImpl.uploadPicture




# 图片功能扩展
基础属性搜索  
以图搜图  
颜色搜索  

图片分享  
链接分享  
扫码分析  

图片批量管理  
批量修改信息  
批量重命名  

**以图搜图**  限定在个人空间使用  
需求是全网搜索  
2种方案： 第三方API和数据爬取（爬虫）  

调用接口 使用百度识图通过url上传图片，然后分析百度识图的api 仅作学习用
定义api包 使用hutool工具类 构造请求参数 发送请求解析相应  
**注意：百度的识图url调用有概率失败 目前是简单的for循环重试 后续可以使用guava包实现更精确的重试机制 或者使用付费api**  
使用设计模式中的门面模式 把三个调用接口的逻辑合并 方便调用 **高内聚低耦合**

**颜色搜图** 限定在个人空间使用  
为了提升性能，避免每次搜索都实时计算图片主色调，在创建图片时 就获取图片主色调存入数据库

提取图片颜色 使用云服务API或者OpenCV图像处理库  **使用COS数据万象获取**
存储颜色特征  
用户查询输入  
计算相似度  相似度算法，根据用户指定颜色，使用相似度计算，比如欧氏算法，余弦相似度
返回结果  

**计算颜色相似度**  
欧几里得距离算法： 颜色可以使用RGB值标识，通过计算两种颜色RGB值之间的欧利记得距离判断相似度

**图片分享**
纯前端功能


**图片批量管理**
允许用户批量管理图片信息，比如批量重命名  
**扩展** spring表达式
spring表达式简称SpEL用于在spring配置文件或java代码中动态的查询和操作对象，SpEL可以在运行时解析表达式，并执行对java对象的访问，操作和计算，支持
丰富的功能，如条件判断，方法调用，属性访问，集合处理，正则表达式等  
比如：  
#{user.name} 访问user对象的name属性
#{person.address.city} 访问签到对象地址中的city属性
#{person.address.city == '上海'} 判断city属性是否等于上海

**比如使用表达式根据方法参数动态生成缓存的key**
```java
@Cacheable(value = "user",key = "#id+ ':' + #locale'")
public User getUser(Long id, Locale locale){
return userService.getUser(id,locale);
}
```  

他的实现方式不是字符串替换，而是用到了AST抽象语法树对字符串进行解析


# **AI图片编辑**  

**基础图片编辑**   **纯前端**
功能 裁剪多余部分，旋转图片，放大缩小尺寸 
**注意： 这个需要去cos中配置跨域**
因为我们本地是localhost 然后对象存储的地址和我们本地不是一个地址 会出现跨域问题
在腾讯云cos-安全管理-跨域访问cors设置中 配置我们的地址即可

**AI图片编辑-扩图**  
AI绘图大模型选择**阿里云百炼**  
https://bailian.console.aliyun.com/?tab=api#/doc/?type=model&url=https%3A%2F%2Fhelp.aliyun.com%2Fdocument_detail%2F2796845.html  
云百炼使用的是异步的方式 因为扩图耗时会比较大 所以为了减少服务器压力 所以使用异步调用  
所以客户端调用接口要轮询检查任务是否完成，完成就获取图片  
**这里使用前端轮询请求后端接口 然后后端去调用ai**  

在api包下创建阿里云百炼api需要的实体类 然后参考文档写代码即可


# 图库分析  
用户空间图库分析  
管理员全空间分析

流程： 
**数据采集：**  
从数据源获取原始数据，明确涉及的表和字段，必要时采用分页查询处理大数据量  
**数据预处理：**  
对数据进行清理 加工和格式化，包括过滤无效信息，解析复杂字段 比如json格式的tags，以及通过字段关补充上下文信息  
**数据计算：**  
根据需求进行分组，聚合，排序等，从而计算关键指标 根据场景调整计算方案  
**数据存储，可选：**  
针对频繁查询的分析结果，可以将结果数据存储作为单独的表或缓存，减少重复计算，提高查询效率  
**数据接口涉及：**  
为前端提供统一接口 支持查询和展示 要考虑数据量较大导致前端渲染卡顿的情况，可按需返回精简的字符串
**数据可视化：**  
通过图标展示分析结果 前端使用Apache Echarts渲染  


# 团队空间
团队共享素材  

1. 创建团队空间  
    用户可以创建最多一个团队贡献空间，用于团队协作，资源共享，空间管理员拥有私有空间的所有能力  
2. 空间成员管理  
    成员要求：空间管理员可以邀请新成员加入团队，共享空间内的图片  
    设置权限：空间管理员可以为成员设置不同的角色 比如查看者，编辑者，管理员 控制成员的权限范围  
3. 空间成员权限控制  
    仅特定角色成员可访问或操作团队空间内的图片  
4. 空间数据管理  
    对特定空间数据进行单独管理，不和公共图库，私有空间图片混在一起  

**使用space表的spaceType区分空间类型**  
只有团队空间才有成员的概念

**空间成员权限控制**  
**RBAC权限控制**  
对于复杂的权限控制场景，可以采用经典的RBAC权限控制模型（基于角色的访问控制，Role-based Access Control） 核心概念包括 用户，角色，权限
- 一个用户可以有多个角色
- 一个角色可以有多个权限  

**一般来说标准的RBAC实现需要五张表，用户表，角色表，权限表，用户角色关联表，角色权限关联表 有一定开发成本，本项目团队空间不需要那么多角色
简化RBAC实现方式，把权限定义到配置文件中**

**权限校验实现方案**  
1. 最直接的方法就是之前校验私有空间权限一样 封装团队空间的权限校验方法 或者类似用户权限校验写个注解+AOP却面
2. 对于复杂的角色和权限管理，可以选用现成的第三方权限校验框架来实现，编写一套权限校验规则代码后，就能整体管理系统的权限校验逻辑了
3. 本项目采用主流的权限校验框架**Sa-Token**


**空间数据管理**
考虑团队空间图片数量可能比较多 可以对特定空间数据进行单独管理  
给每个团队空间单独创建一张图片表，也就是**分库分表中的分表**，而不是和公共图库，私有空间的图片混在一起  
这样不仅查询空间内图片效率更高，还便于整体管理和清理空间，但是要注意 **仅对旗舰版空间生效，否则分表数量特别多反而影响性能**  
**使用Apache ShardingSphere实现随着新增空间不断增加分表数量的动态分表**  



**空间成员权限控制**  
权限校验属于整个项目公共服务 放在manager.auth中  
使用配置文件代替数据库表做权限校验 spaceUserAuthConfig.json  
然后在manager.auth.model下 定义实体类和配置文件字段一一映射  

**sa-token**  
首先引入依赖  
sa-token默认将数据保存在内存中，此模式读写速度最快 且避免了序列化与反序列化带来的性能消耗  
但缺点是重启后数据会丢失，无法在分布式环境中共享数据  
可以参考官方文档让sa-token整合redis，将用户的登录态等内容保存在redis中  
这里使用jackson序列化的方式整合redis，这样存到redis的数据是刻可读的


**新建账号体系**  
定义门面类StpKit 确保不影响原有的鉴权方式  
比如：  
在当前会话进行space账号登陆  
StpKit.SPACE.login(xxxx)  
检测当前会话是否以space账号登录，并具有picture:edit权限  
StpKit.SPACE.checkPermission("picture:edit")  

**更改登录逻辑 额外保存数据到StpKit中 （sa-token）**  
定义上下文类 统一管理权限可能要用到的参数  
从请求中获取上下文对象 stpinterfaceimpl 获取当前请求的权限控制逻辑需要用到的参数（上下文类中的参数）  

**编写通用的权限校验逻辑 兼容公共图库，私有空间和团队空间** StpInterfaceImpl.getPermissionList  
注意： 因为目前是satoken鉴权 只要打上注解的方法都会强制要求登陆后才能访问  
所以在picturecontroller中 getpicturevobyid和getpicturevobypage不能使用注解的方式直接鉴权，而是使用编程式的方式鉴权  

补充获取权限接口 返回给前端时 带上权限列表 给spaceVO和PictureVO增加权限列表字段

**空间数据管理**  
每个团队空间的图片数据存储到一张单独的表 也就是分表  
使用Apache ShardingShpere 引入依赖  

**静态分表**
设计阶段 分表数量和规则是固定的 不会根据业务增长动态跳转  
分片规则通常基于某一字段 通过简单规则 决定数据存储在哪个表或者库  
优势是简单，好理解 缺点是不利于扩展 随着数据增长要手动调整份表数据并迁移数据  
静态分表只要在配置文件中编写配置就行了 不需要改任何业务代码 框架会自动帮你改sql 根据pictureid把查询请求路由到不同表中

**动态分表**
分表数量可以根据业务需求或数据量动态增加，表的结构和规则是动态生成的  
动态分表更灵活，扩展小强，适合数据量快速增长的场景    
缺点是实现更复杂 需要动态生成表并维护表的元信息，如果没用控制好，分表特别多反而影响代码的性能  
**要自定义分表算法类，还要在代码中编写动态创建表的逻辑**  

**如果要使用分表 spaceId必须不能为null 约定公共空间spaceid都为0**

这里不做改造 可以选择关闭分库分表： 在启动类排除掉分库分表的配置，
注释掉分库分表管理类的component注解 然后注释掉代码中使用的地方


 
# 图片协同编辑  
websocket 事件驱动涉及 disruptor无锁队列  
仅在团队空间才会生效，协同编辑操作包括 左旋右旋放大缩小

**协作交互流程**  
多人写作时，每个用户的动作都需要通知到其他用户，通知消息的用户需要进行相应的处理  
比如用户A放大了图片，就需要给其他正在编辑的用户发送 图片放大 消息，其他用户收到这个消息后，需要同步放大自己页面的图片  
这其实是一种**事件驱动**的架构思想，写作编辑中的每个用户动作本质上是一个**事件**，执行动作时会产生事件并提交给服务器  
服务器收到事件后，会转发给其他用户，其他用户收到事件后，就要作为事件的消费者来处理事件

事件驱动事件可以解耦生产者和消费者 他们中间有一个事件分发器  
相比于生产者直接调用消费者，事件驱动模型的主要优点在于**解耦和异步性** 在事件驱动模型中，生产者和消费者不需要直接依赖于
彼此的实现，生产者只需要触发事件并将其发送到事件分发器，消费者则根据事件类型处理逻辑，这样可以多个消费者的独立响应同一事件
（比如一个用户旋转了图片，其他用户都能同步）， 系统更加灵活，可扩展性更强。此外，事件驱动还可以提升系统的**并发性和实时性**
可以理解为多引入了一个中介来帮忙，通过异步消息传递，减少了阻塞和等待，能够更高效的处理多个并发任务

**事件触发者               事件类型            事件消费者（其他用户处理）**  
  用户A建立连接，加入编辑      INFO          显示用户A加入编辑的通知  
  用户A执行编辑操作          EDIT_ACTION    放大/缩小/左旋/右旋当前图片   
  用户A断开连接，离开编辑      INFO          显示用户A离开编辑的通知  

**协作冲突**  
事件通常是**并发的**而不少严格的顺序执行，这种并发会引发**协作冲突**     
这里通过业务涉及解决协作冲突，而不是加锁 约定**同一时刻只允许一位用户进入编辑图片的状态** 此时其他用户只能实时浏览到修改效果
但不能参与编辑，进入编辑状态的用户可以退出编辑 其他用户才可以进入编辑状态  
这里可以了解一下**OT算法** 但是对于本项目 只是图片编辑 OT算法并不是最优解 OT算法一般广泛应用于文档协同编辑

**提高协作实时性**
在实时通讯的业务场景中，常用的技术方案包括长轮询，SSE和WebSocket,由于本项目业务需求需要频繁且高效的双向通信，所以这里使用**WebSocket实现即时通讯**  

**WebSocket**  
是一种**全双工通信协议** 让客户端（比如浏览器）和服务器之间可以保持实时，持续的连接，和传统的HTTP-响应模型不同，WebSocket是一条**常开的隧道**  
连接的双方可以随时发送和接收数据，而不需要不断的建立连接和关闭连接

比如：
HTTP就像点外卖： 每次下单（请求）-到货（响应）都是一次独立的操作，完成后关闭连接  
WebSocket像是打电话 打电话建立连接，随时聊天就是双向通信，直到挂断就是关闭连接

**WebSocket和HTTP的关系**  
虽然是两种不同的通信协议，但是他们都是基于TCP协议，都可以在同样的端口上工作（比如80和443）  
**首先要明确，WebSocket是建立在HTTP基础之上的** WebSocket的连接需要通过HTTP协议发起一个握手（HTTP Upgrade请求），这个握手请求是WebSocket建立连接的前提  
表明希望切换协议，服务器如果支持WebSocket，会返回一个HTTP 1001状态码，标识协议切换成功  
握手完成后，HTTP协议的作用就结束 同心会切换为WebSocket协议，双方可以开始进行全双工通信  

**具体业务流程**
1. 建立连接之前，先进性用户权限校验，校验通过后，把登录用户信息，要编辑的图片信息保存到要建立的WebSocket连接的会话属性中  
2. 建立连接成功后，把WebSocket会话保存到该图片对应的会话集合中，便于后续分发消息给其他会话  
3. 前端将教习发送到后端，后端根据消息类型分发到对应的处理器  
4. 处理器处理消息，将结果作为消息发送给需要的WebSocket客户端  
5. 当前端断开连接时，删除会话集合中的WebSocket会话，释放资源  

这里使用spring原生的WebSocket进行开发  

**编码**
引入WebSocket依赖  
manager包下新增websocket包  
model包存放响应体请求体 枚举类  
WSHandshakeInterceptor设置拦截器逻辑  
PictureEditHandler定义发送消息的逻辑 （建立连接成功做什么，接收到前端消息做什么 关闭连接后做什么）  
WebSocketConfig配置类，配置拦截器和handler  

**现存的系统问题**
WebSocket通常是长连接，每个客户端都需要占用服务器资源  
在spring websocket中，每个websocket连接对应一个独立的websocketsession，消息的处理是在该websocketsession所属的线程中执行  
如果**同一个**websocket连接连续发送多条消息，服务器会**按照接收的顺序一次同步处理**而不是并发执行，这是为了包装每个客户端的消息处理是线程安全的  
虽然多个客户端的消息处理可以并发执行，但是接收消息和具体处理消息的是同一个线程，如果处理消息耗时长，并发又高，可能会导致系统响应事件编程，甚至因为资源耗尽而服务崩溃  
**这里可以和tomcat一起理解 tomcat服务器默认最多接收200个请求 如果你在一个接口内定义Thread.sleep（100000L）的话 你会发现大概200次以后就没有线程来
处理请求 这时候就会卡死**  
最简单的解决方法就是： **就是开一个线程专门来异步处理消息**，但是还要包装操作是按照顺序同步给其他客户端的，因此还需要引入一个队列，把任务按照顺序放到队列中，交给线程去处理  
异步操作+任务队列获取任务执行，使用线程池就可以实现  

但是对于协同编辑场景，需要尽可能保证低延迟，因此选用一种高级技术**Disruptor**无锁队列来减少线程上下文的切换，能够在高并发场景下保持低延迟的高吞吐量   

**Disruptor**
高性能并发框架，是一种**无锁的环形队列数据结构**  
支持生产者-消费者模式，可以作为消息队列使用 适用于进入交易，实时处理等对实时性要求高的场景  
而且 disruptor还要有一个优点，可以将任务放到队列中，通过优雅停机机制，在停止时，会先将队列中的任务处理完，再停止服务，从而防止消息丢失
延迟非常低  

主要通过以下几点实现高性能这消息传递机制  
环形缓冲区：使用固定大小的数组，可以复用内存，避免了频繁的内存分配和垃圾回收
无所设计： 依赖cas和内存屏障，降低了线程切换的开销
缓存友好：最大利用cpu缓存局部性，提高访问速度
多消费者模式：支持多消费者共享同一环形缓冲区，并能配置不同的消费策略


引入disruptor
同样根据文档 开发 config，handler和producer
config配置类引入handler








  















 































