
# 1. 项目初始化
工具包：
- mybatisPlus
- hutool
- knife4j 自动生成接口文档   访问： http://localhost:9999/api/doc.html

**项目基础代码** 
请求响应体封装

    封装前端传参和后端返回参数的实体类，便于传输数据  
    com.scg.scgpicturebackend.common

异常封装 

    封装异常类，便于处理异常自定义错误码，对错误进行收敛，便于前端统一处理
    定义全局异常处理器
    com.scg.scgpicturebackend.exception

**解决跨域**

只在浏览器出现，是浏览器的同源策略，如果发送请求的网址和接收请求的网址是相同的 否则就会有跨域问题

 解决跨域问题的方法：

    1.后端来支持跨域
    2.代理 nginx 第三方工具等方法
    3.直接用croscheck注解
    4.全局跨域配置 com.scg.scgpicturebackend.config.CorsConfig


# 2. 用户模块
注册，登录，获取当前登录用户，注销，权限控制，用户管理

使用mybatisX插件生成实体类等代码 

- 定义user表的枚举类
- 定义请求接受类和请求封装类 dto
- 设置要返回给前端哪些数据（脱敏） vo
- 权限控制 配合aop和注解类实现 authInterceptor+AuthCheck
- 分页 使用mybatisplus分页 
-  **天坑： 3.5.9的mybatisplus要额外安装分页插件和配置一个配置类**
-  **天坑： 要注意 前端和后端的long精度不一样 如果直接传的话可能会丢失精度 因为这里的user id是assign_id策略 生成的long比较大 可能前端没有这么高的精度 所以要定义一个配置类JsonConfig来对long进行转换**



#  3. 图片模块
管理员功能： 上传，创建，管理，修改  
用户功能： 查看，搜索，查看详情，下载  
主页的公共图库 都可以进行浏览 图片管理只有管理员可以浏览
主页图库显示的图片都是一样的 但是管理员不会脱敏 用户会脱敏
**目前只有管理员可以上传图片**

**tips：数据库加索引 如果索引varchar类型长度累计和大于2048 就会报错**

图片上传路径不用自己服务器 使用腾讯云的cos对象存储 

**上传图片方案：**  
上传图片时直接保存记录：**在用户上传图片后，系统立即生成图片的完整数据记录**
（包括图片url和其他信息）无需等待用户提交，图片信息就立刻存入数据库，之后用户再填写其他图片信息  
**然后当点击创建按钮 相当于编辑了已有图片记录的信息 便于对图片进行朔源**

上传区分新增和更新两个操作使用saveorupdate （目前只有管理员可以更新图片 更新调用的也是新增接口 但是前台会传这个图片的id 如果图片id有值在数据库 
那么说明是更新操作）

解析图片信息：  
这里使用了腾讯云cos 直接使用**数据万象**服务获取图片基础信息  

**根据腾讯云接口文档编码**  
引入对象存储的依赖cos_api

配置文件CosClientConfig，以及本地用的application-local.yml  
文件上传下载通用类：CosManager 单纯的通过腾讯云提供的api上传下载


**下载图片方案**  
先通过后端服务器进行权限校验  
然后返回给前端一个临时密钥  
之后前端可以凭借密钥直接从对象存储下载，不用经过服务端中转 性能更高

**通用文件上传服务**  
FileManager 包含一些逻辑处理代码


# 4 用户传图
用户上传 审核 涉及用户上传（UGC）就需要增加审核功能  
通过url创建图片  
批量抓取和创建图片  

**用户上传，审核**  
修改图片查询 给查询增加审核条件

**url导入图片**  
下载图片 后端从服务器下载图片到本地  
**校验图片**  
**对url本身进行校验** 首先校验url字符串本身合法性 然后使用**head**请求来去获取url对应文件的辕信息
head请求只返回http响应头信息，不会下载文件内容 **注意不是所有服务器都支持head请求**
**上传图片**
直接上传到cos

**更改FileManager使用模板方法 去优化选择图片上传的方法和用url上传图片的方法**  
把公共部分拆出来 然后让子类去自定义自己的实现逻辑
**废弃掉FileManager类**  
使用manager/upload文件夹中的使用模板方法重构的类  
**修改pictureservice的调用代码 改为使用模板方法的上传方法调用**  

**批量抓取图片**  
爬！  
批量从网络抓取并创建图片的功能 千万别给普通用户开放，这相当于所有用户使用我们服务器作为爬虫源头 这太刑了

而且爬也别去爬素材网站 绝大多的素材网站都有版权保护  
这里选择从搜索引擎获取图片

有两种常见的做法：  
1. 请求到完整页面内容，对页面的html结构进行解析，提取到图片的地址，再通过url下载
2. 直接调用后端后去图片地址接口拿到数据

具体使用哪种方法看情况分析，这里我**使用bing图片进行抓取** bing图片网页下拉刷新查看接口即可 简单来说你想办法获取新图片的加载就很容易找到  
其他网站大差不差 这里只做学习用 不提供任何建议 
bing图片的请求地址 https://cn.bing.com/images/async?q=%图片内容&mmasync=1  
地址中的mmasync一定要加上

**使用jsoup来提取html文档解析图片地址 非常轻量**  
先通过类选择器找到最外层元素 然后通过子元素选择器找到图片地址

**抓取规则：**  
输入搜索关键字，单次抓取最好不超过30条



# 5.图片优化
图片查询优化 - 分布式缓存，本地缓存，多级缓存  
图片上传优化 - 压缩，秒传，分片上传，断点续传  
图片加载优化 - 懒加载，缩略图，CDN加速，浏览器缓存  
图片存储优化 - 降频存储（冷热数据分离） 清理策略  

**使用redis进行缓存**  
使用spring data redis 作为redis的操作库


**Caffeine本地缓存**  
本地缓存是本地内存的缓存，它不需要持久化，也不需要网络连接，它直接存在于JVM的内存中，所以它的速度非常快，但是它不能持久化，所以当JVM重启时，它将丢失。  
适用于小型数据库 因为在服务器 服务器内存很宝贵
不需要服务器共享数据的单机应用
高频，低延迟的访问场景  session也是存在了本地缓存中

本地缓存需要自己创建初始化缓存结构 可以理解为自己要new一个hashmap  
本地缓存本身是服务器隔离，占用服务器内存，key可以精简点不用加前缀

**多级缓存，redis和本地缓存一起使用 这样可以兼顾本地缓存和redis缓存的优点**  
先查本地缓存-有直接返回-没有查询redis-有返回-没有查询数据库-更新双缓存

**图片压缩**
把图片格式转为体积更小的格式，比如webP，对图片质量进行压缩，缩小图片尺寸  
这里使用第一种方法，因为图片网站尽量不要影响图片的质量

webP: 比png文件小26%，比JPEG文件小25%-34% 支持透明背景 兼容大部分主流浏览器
AVIF：基于AV1视频编码技术的压缩及时 压缩效率更高  
这里选择上传时压缩，一次压缩永久保存，无需额外的压缩费用  
压缩逻辑： 先上传原图 然后再压缩一张图片保存 然后把压缩后的图片名(webp)存入数据库 也就是说 实际在cos反而数据变多了 但是我们网站查询数据变少了  
         后续可以考虑上传成功后从cos中删除原图 或者保存原图和压缩后的图的数据在数据库 但是查询只查询压缩后的图

修改CosManager

**文件秒传**  
客户端生成文件唯一标识 上传时通过客户端计算唯一标识 如果能够在数据库查询到说明存在相同文件 那么直接返回文件存储路径，不存在再正常上传  
这个项目不适合用秒传，因为文件比较小，重复文件也较少，而且使用了腾讯云cos存储 只能通过唯一文件地址去查询文件  
但是可以设计一个关联表 用户1的图片地址为/1/a.png 用户2的图片地址为/2/a.png 然后为他们创建一个快捷方式一样的功能 让这两个地址都指向/b.png 相当于做一个数据库的关联表

**断点续传**  
原理是把一个文件切分成多个块 如果中断从上次最后上传的块开始上传  
断点续传和分块上传是一起用的  
这个功能腾讯云cos也有提供  
这里不做实现 知道这个原理就行

**图片缩略图**
首页的图片应该生成一份尺寸更小的缩略图，点击图片或者浏览图片的时候才加载原图  
使用cos的图片持久化处理  
picture表新增缩略图url字段  
修改CosManager  

现在图片大小顺序为 缩略图 < 压缩图 < 原图

**懒加载**
避免一次性加载所有图片，只有当资源需要显示才加载，比如图片列表 只加载当前屏幕显示的图片 然后当滚动的时候才加载
其实分页相当于这个功能了 其他的都是前端改动后端不用改动


**浏览器缓存**
通过设置http头信息，让用户浏览器把资源缓存在本地，在用户再次访问同样的资源 直接加载缓存，不用请求服务器
设置cache-control public，private，no-cache，no-store
但是要确保缓存及时更新，给文件添加日期随机数防止重复

**CDN**
通过将图片文件发送到全球各地的节点，用户访问时访问离自己地址最近的节点去拿资源  
**CDN请求核心过程：**
1. 用户文件有源站（最原始存储图片的位置 这个项目是COS） 上传到CDN服务进行缓存
2. 当用户请求图片时，CDN会根据用户的地理位置，返回离用户最近的CDN节点缓存的图片资源
3. 未命中缓存的图片会从源站获取，并缓存再CDN节点，让后续用户访问，俗称回源

**优点**
快，安全。 COS倾向存储，CDN倾向网络请求 资源访问高，流量消耗大，要考虑使用CDN  
CDN的流量和请求单价低于对象存储，而且更加安全，可以**保护源站地址不被泄露**  这样访问就变成了先去CDN然后CDN去源站拿数据（前提是没命中缓存在CDN上）这也保护了源站的安全性  
如果系统不安全 那么就想办法加一个中间层

CDN使用起来简单，但是怎么安全的使用很麻烦  
1. 缓存策略：为静态资源（如图片，css，js）设置长期缓存时间，减少回源的次数和消耗
2. 防盗链：配置refer防盗链防止盗刷 比如仅允许自己的域名可以加载图片
3. 单ip限制
4. 设置https，配置ssl证书
5. 给CDN加监控告警 一定时间超出了配置的流量直接告警
6. 节点选择 非必要不要开全球CDN节点
7. 开启访问日志 分析用户行为和流量来源 适合访问量较大的场景 好像也要钱

**上线后再实现这个功能**


**图片存储优化**  
**数据沉降**配置多久后 文件沉降到低频存储，归档存储，深度归档存储  
每种存储的存储价格都不一样 越靠后的越便宜  
但是需要注意 越靠后的数据虽然存储价格不贵 但是后续访问 回源 取回费用较贵  
**所以 应该先分析，再沉降**

**数据沉降和数据的冷热分离概念是比较接近的**，冷热数据分离是根据数据的访问热度，将访问频繁的数据和交少的数据存储在不同的存储层中  

二者的差距：
个人理解的是 数据沉降更秦湘语关注一个对象的生命周期（一个资源从热到冷） 目标更多的是降低存储成本，配置沉降规则后也一般不会调整
冷热数据分离更关注整个系统的资源分布，比如热门图片放到高性能磁盘，冷门图片归档存储，目标是同时优化性能和节约成本，数据的热度可以实时调整  
**这里要知道这个思路**  

**数据清理**
页面点击删除后 使用async异步启动子线程去删除cos中的数据

使用redis管理sesison 引入springsession+redis 修改配置  
这样登陆后 会保存3个key  
一个是session本身，session过期时间，session一些额外的信息




























